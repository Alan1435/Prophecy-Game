// src/game/systems/TooltipSystem.ts
import * as PIXI from 'pixi.js';
import { GameState } from '../interfaces/GameState';

export class TooltipSystem {
    container: PIXI.Container;
    background: PIXI.Graphics;
    text: PIXI.Text;
    private currentId: string | null = null;
    private fadeTimeout: NodeJS.Timeout | null = null;
    private calculateClickValue: (state: GameState) => number;
    private calculatePassiveValue: (state: GameState) => number;

    constructor(
        clickValueCalculator: (state: GameState) => number,
        passiveValueCalculator: (state: GameState) => number
    ) {
        this.calculateClickValue = clickValueCalculator;
        this.calculatePassiveValue = passiveValueCalculator;

        this.container = new PIXI.Container();
        this.background = new PIXI.Graphics();
        this.text = new PIXI.Text('', {
            fontFamily: 'Arial',
            fontSize: 16,
            fill: 0xffffff,
            wordWrap: true,
            wordWrapWidth: 300
        });

        this.container.visible = false;
        this.container.addChild(this.background);
        this.container.addChild(this.text);
        
        // Set initial z-index high to ensure tooltips are always on top
        this.container.zIndex = 1000;
    }

    showTooltip(title: string, description: string, x: number, y: number, tooltipId: string, state: GameState) {
        // Clear any existing fade timeout
        if (this.fadeTimeout) {
            clearTimeout(this.fadeTimeout);
            this.fadeTimeout = null;
        }

        // Store current tooltip ID
        this.currentId = tooltipId;

        // Update content
        const updatedDescription = this.getUpdatedDescription(tooltipId, description, state);
        this.text.text = `${title}\n\n${updatedDescription}`;
        
        // Update background
        this.background.clear();
        this.background.beginFill(0x000000, 0.9);
        this.background.drawRoundedRect(
            0,
            0,
            this.text.width + 20,
            this.text.height + 20,
            10
        );
        this.background.endFill();

        // Position text within background
        this.text.position.set(10, 10);

        // Position tooltip container
        this.updatePosition(x, y);
        
        // Show tooltip
        this.container.visible = true;
        this.container.alpha = 1;
    }

    hideTooltip() {
        if (this.container.visible && this.container.alpha > 0) {
            this.fadeOut();
        }
    }

    updatePosition(x: number, y: number) {
        if (!this.container.visible) return;

        const padding = 20;
        let tooltipX = x + padding;
        let tooltipY = y + padding;

        // Get screen dimensions
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;

        // Ensure tooltip stays within screen bounds
        if (tooltipX + this.container.width > screenWidth) {
            tooltipX = x - this.container.width - padding;
        }
        if (tooltipY + this.container.height > screenHeight) {
            tooltipY = y - this.container.height - padding;
        }

        // Keep tooltip on screen if it would go off the left or top
        tooltipX = Math.max(padding, tooltipX);
        tooltipY = Math.max(padding, tooltipY);

        this.container.position.set(tooltipX, tooltipY);
    }

    private fadeOut() {
        const fadeStep = 0.1;
        const fadeInterval = 16; // Approximately 60fps

        const fade = () => {
            if (this.container.alpha > 0) {
                this.container.alpha -= fadeStep;
                this.fadeTimeout = setTimeout(fade, fadeInterval);
            } else {
                this.container.visible = false;
                this.currentId = null;
                this.fadeTimeout = null;
            }
        };

        if (this.fadeTimeout) {
            clearTimeout(this.fadeTimeout);
        }
        this.fadeTimeout = setTimeout(fade, fadeInterval);
    }

    getUpdatedDescription(tooltipId: string, baseDescription: string, state: GameState): string {
        switch(tooltipId) {
            case 'divine-energy':
                const maxClickPower = 10 + (state.completedPaths.persistence * 10);
                return `Your main resource. Generated by clicking the altar and passively through blessings.\n\n` +
                       `Current Generation:\n` +
                       `• Click: ${this.calculateClickValue(state).toFixed(2)} per click\n` +
                       `• Max Click Power: ${maxClickPower}\n` +
                       `• Passive: ${this.calculatePassiveValue(state).toFixed(2)} per second\n` +
                       `• Total Earned: ${Math.floor(state.divineEnergy)}`;
            
                       case 'prophecy-progress':
                        const requirement = state.completedPaths ? 
                            (100 * Math.pow(1.5, 
                                state.completedPaths.patience + 
                                state.completedPaths.persistence + 
                                state.completedPaths.piety
                            )) : 100;
                    
                return `Your journey towards fulfilling the ancient prophecy.\n\n` +
                       `Progress is gained based on your Divine Energy generation.\n` +
                       `Each point of Divine Energy adds 0.1 to your progress.\n\n` +
                       `Current Progress: ${Math.floor(state.prophecyProgress)}/${Math.floor(requirement)}`;
            
            case 'blessings':
                return `Powerful blessings that enhance your divine powers.\n\n` +
                       `Current Blessings:\n` +
                       `• Meditation: ${state.blessings.meditation.toFixed(1)} (Click Power)\n` +
                       `• Prayer: ${state.blessings.prayer.toFixed(1)} (Both Click & Passive)\n` +
                       `• Rituals: ${state.blessings.rituals.toFixed(1)} (Passive Gain)\n` +
                       `• Wisdom: x${state.blessings.wisdom.toFixed(1)} (Global Multiplier)`;
            
            default:
                return baseDescription;
        }
    }
}